<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-a11y-keys/iron-a11y-keys.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<!--

Imagine you are using Polymer, you have a **record on your database, and want to save it** using a web form. **You follow tutorials**, and you find that everything works as expected: you make up a form (it could be an iron-form), you run it, and the record appears. **You think this is a success** -- until you put this form in the real world and discover that **all those tutorials were lying. They were showing you that something with pedals and two wheels will move faster -- but failed to show you that in order to ride it you also need breaks, lights, a helmet;** yes, they are all props. But yes, **you always need them**.

Ask yourself these questions:

* Do you need to load data from the server before showing the form?
* Do you want to overwrite a record (PUT with an existing ID), or create a new one (POST, no ID) or create a record with an arbitrary ID (PUT with a new ID)? Do you realise that you will need POST or PUT calls?
* Do you want to highlight the problem fields if the form is NOT a success?
* Do you want to submit the form when the user presses ENTER on a paper-input widget?
* Do you want to refresh the data with the saved info coming back from the server after saving?
* Do you want to make it possible for other widgets to display messages to the user?

If the answer is yes, and you are coding this each time from scratch, then maybe you should consider using a decorator element that does _all_ of this for you. **Welcome to `hot-form`**.

Imagine you have a form like this:

    <hot-form>
      <form is="iron-form" method="post" action="/stores/polymer">
        <paper-input required id="name" name="name" label="Your name"></paper-input>
        <paper-input required id="surname" name="surname" label="Your surname"></paper-input>
        <paper-button type="submit" raised on-click="_submit">Click!</paper-button>
      </form>
    </hot-form>

Here is what it does, and how.

## Invalidate fields based on server response

The server normally responds either with an OK status (200, 201, etc.) or with an error status. In case of errors, the server normally will tell you what the problem was, and which fields were affected. Unless you enjoy repeating code, you want the "invalidation" to happen automaticallty.

If the server returns errors (for example 422), `hot-form` will expect a JSON object back from the server like so:

    {"message":"Unprocessable Entity","errors":[{"field":"name","message":"Not good!"}]}

This will cause `hot-form` to set the field named `name` as `invalid`, with the invalid message set as `Not good!`.

## Emit events so that other widgets can display messages

The element will fire the following messages:

* `user-message-info`. Fired when there is a message to give the user. `e.detail` will have `{ message: msg }`
* `user-message-success`. Fired when a successful response is received. `e.detail` will have `{ message: msg }`
* `user-message-error`. Fired when an error response is received. `e.detail` will have `{ message: msg }`

These events will bubble up. So, you can put elements that listen to them, and display these messages to the user.

## Make the right request to the server (PUT or POST), based on `record-id`

If `record-id` is set, the element will make sure that, the `request` object used by the `iron-ajax` form is manipulatd before sending it, so that the `action` attribute is changed to `/original/url/:recordId`, and the method used by `iron-ajax` is `PUT`. This means that the element can be used to make spefific PUT calls on specific records, based on `recordId`. For example:

    <hot-form id="hot-form" record-id="57902ef29b880cd678a3d7a9">
      <form is="iron-form" id="iron-form" method="POST" action="/stores/polymer">
        <paper-input required id="name" name="name" label="Your name"></paper-input>
        <paper-input required id="surname" name="surname" label="Your surname"></paper-input>
        <paper-input required type="number" id="age" name="age" label="Your age"></paper-input>
        <paper-toggle-button id="active" name="active" label="Active?">Active?</paper-toggle-button>
        <paper-button raised type="submit">Click!</paper-button>
      </form>
    </hot-form>

When the form is submitted, `PUT /stores/polymer/57902ef29b880cd678a3d7a9` will actually be called.

## Load of record with an AJAX call, pre-setting corresponding form values

If `record-id` is set, the element will make a GET AJAX call to the `action` URL (in the example above, `GET /stores/polymer/57902ef29b880cd678a3d7a9` fetching the current record's value. It will also pre-set the form's value to
match those returned by the server.
Note: the response must be a JSON record, where each field's key corresponds to the element's `name` attribute. In the example above, a valid JSON in return would be:

    {
      "name":"Tony",
      "surname":"Mobily",
      "age":40,
      "active":false,
      "id":"57902ef29b880cd678a3d7a9",
    }

This means that you can create your form, _and_ know that the existing record's value are already set.

## Sane submission when pressing "enter" or clicking the submit button

This element allows you to automatically submit form when you press enter on a `paper-input` field, or when clicking on the button marked as `type=submit`.

Yes, you have to do these things by hand normally (!). Every time. Just wrap your form with hot-form, and you won't have to worry about it.

    <hot-form>
    ...
    </hot-form>

If you want to disable "submit by pressing enter", just add `no-enter-submit` to `hot-form`.

    <hot-form no-enter-submit>
    ...
    </hot-form>

If you don't want to submit the form with a button automatically, just avoid setting a paper-button as `type=submit`.

@group Hotplate Elements
@element hot-form
@demo demo/index.html
-->

<script>
  /*
   * Monkey patching of Polymer to add recursive queries on effective children
   * To be added to its own Github module
   * https://github.com/Polymer/polymer/issues/3805
  */
  Polymer.DomApi.prototype.queryDistributedElementsDeep = function( selector, doNotVisitSelector ){
    var list = [];
    function visit( node ){
      var c$ = Polymer.dom( node ).getEffectiveChildNodes();
      for( var i = 0, l = c$.length, c; (i < l), ( c = c$[ i ] ); i ++ ){
        if (c.nodeType === Node.ELEMENT_NODE ){

          // If selector matches, add
          if( Polymer.DomApi.matchesSelector.call( c, selector ) ){
            list.push( c );
          }

          // Visit element's children, unless it matches doNotvisitSelector
          if( !doNotVisitSelector || !Polymer.DomApi.matchesSelector.call( c, doNotVisitSelector ) ){
            visit( c );
          }
        }
      }
    }
    visit( this );
    return list;
  }

  Polymer.Base.queryEffectiveChildrenDeep = function( slctr ){
    var e$ = Polymer.dom(this).queryDistributedElementsDeep(slctr);
    return e$ && e$[0];
  }

  Polymer.Base.queryAllEffectiveChildrenDeep = function( slctr ){
    return Polymer.dom(this).queryDistributedElementsDeep(slctr);
  }


</script>

<dom-module id="hot-form">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <!-- The data loader, used to load recordId if required-->
    <iron-ajax id="request" on-response="_dataLoaderResponse" on-error="_dataLoaderError"></iron-ajax>


    <!-- iron-a11y widget used to catch if a user presses ENTER in an input field -->
    <iron-a11y-keys id="a11y" keys="enter" on-keys-pressed="_a11ySubmit"></iron-a11y-keys>

    <!-- The actual content distributed, from the light DOM -->
    <content id="contentNode"></content>

  </template>

  <script>
    Polymer({

      is: 'hot-form',

      properties: {

        /**
         * The record ID, used to load data from server (if recordIdAutoLoad is set)
        */
        recordId: {
          type: String,
          notify: true,
        },


        /**
         * By default, if `record-id` is set the form will make an AJAX GET call to the
         * action URL to fetch the current value. This will deactivate this feature
        */
        noRecordIdAutoLoad: {
          type: Boolean,
          value: false
        },

        /**
         * Action once the response to a POST received. It can be `reset` (the form is reset),
         * `set` (the form is set with the returned data) or nothing
         *
        */
        actionAfterPostResponse: {
          type: String,
          value: 'reset'
        },

        /**
         * Action once the response to a PUT received. It can be `reset` (the form is reset),
         * `set` (the form is set with the returned data) or nothing
        */
        actionAfterPutResponse: {
          type: String,
          value: 'set'
        },

        /**
         * The iron-ajax widget used to load data. It's the same interface as
         * iron-form (which also exposes a `request` element)
        */
        request: {
          type: Object
        },

        /**
         * If set to `true`, pressing ENTER in a paper-input field will submit.
         * ALSO when a paper-button in the form marked as "type=submit" is pressed,
         * the form will get submitted
        */
        noEnterSubmit: Boolean,

        /**
         * Message given in case of success. Defaults to "Success!"
        */
        successMessage: {
          type: String,
          value: "Success!"
        },

        /**
         * Submit message given when submit happens. Defaults as "Saving..."
        */
        submitMessage: {
          type: String,
          value: "Saving..."
        },

        /**
         * Message given in case of error AND no error message is
         * returned by the AJAX call (e.g. timeouts, etc.)
        */
        defaultErrorMessage: {
          type: String,
          value: "Error!"
        },
      },

      observers: [
        '_changedRecordId(recordId)'
      ],


      attached: function(){
        this.listen( this.form, 'iron-form-presubmit', '_prepareToSubmit');
        this._wirePaperButtonToSubmit();

        this.listen( this.form, 'iron-form-submit', '_formSubmit' );
        this.listen( this.form, 'iron-form-response', '_formResponse' );
        this.listen( this.form, 'iron-form-error', '_formError' );
      },

      detached: function(){
        this.unlisten( this.form, 'iron-form-presubmit', '_prepareToSubmit');
        this._unwirePaperButtonToSubmit();

        this.unlisten( this.form, 'iron-form-submit', '_formSubmit' );
        this.unlisten( this.form, 'iron-form-response', '_formResponse' );
        this.unlisten( this.form, 'iron-form-error', '_formError' );
      },

      ready: function(){

        // Sets the 'request' attribute
        this.request = this.$.request;

        // Sets the form
        this.form = this.queryEffectiveChildrenDeep( 'form' );

        // Sets the form
        this.submitButton = Polymer.dom( this.form ).queryDistributedElementsDeep( 'paper-button[type=submit]' )[0];

        // Load data (if so required) into the form, depending on recordId
        this._loadData();

        // Sets the a11y target as the form in the light DOM
        // It wasn't done declaratively because the form is in the light DOM
        this.$.a11y.target=this.form;

      },

      // **********************************************************
      // SANE SUBMIT
      // The part of the widget that allows submission on enter on a
      // paper-input widget, and automatic submit when the "type=submit"
      // button is pressed
      // **********************************************************

      _wirePaperButtonToSubmit: function(){
        if( this.submitButton ){
          this.listen( this.submitButton, 'tap', '_onPaperButtonTap');
        };
      },

      _unwirePaperButtonToSubmit: function(){
        if( this.submitButton ){
          this.unlisten( this.submitButton, 'tap', '_onPaperButtonTap');
        };
      },


      _a11ySubmit: function( e ){

        // Only trigger submission if noEnterSubmit is not
        // (I know, double negatives right?)
        if( ! this.noEnterSubmit ){

          // Only trigger submission for paper-input widgets
          if( e.detail.keyboardEvent.srcElement.tagName === 'PAPER-INPUT') {
            this._maybeSubmit();
          }

        }
      },

      // Submit the form when the right button is tapped
      _onPaperButtonTap: function(){
        this._maybeSubmit();
      },

      _maybeSubmit: function(){

        // Don't re-submit if loading
        if( this.form.request.loading ) return;

        // Actually submit the firm
        this.form.submit();
      },

      // **********************************************************
      // RECORD LOADING
      // The part of the widget that makes sure values are loaded
      // **********************************************************

      /**
       * If recordId changes, then new values will need to be loaded
      */
      _changedRecordId( recordId ){
        if( this.form && this.form._readied ){
          this._loadData();
        }
      },

      /**
       * Prepare the `this.request` widget with the right URL (which depends on recordId)
       * and generates the request.
      */
      _loadData: function(){

        // Set the correct URL for the GET, as well as handleAs
        if( this.recordId && ! this.noRecordIdAutoLoad ){
          this.request.url = this.form.getAttribute('action') + "/" + this.recordId;
          this.request.method="GET";
          this.request.handleAs = 'json';

          // This will generate the request, which -- as indicated in the
          // request's declarative definition -- will cause either `_dataLoaderResponse`
          // or `_dataLoaderError` to be called.

          // This is async to give decorating widgets a chance to listen to events
          // before firing
          this.async( function(){
            this.request.generateRequest();
          })
        }
      },

      /**
       * The request by `this.request` worked: pre-fill the form's information
       * with whatever came back.
      */
      _dataLoaderResponse: function(){
        this._setFieldsAsObject( this.request.lastResponse );
      },


      /**
       * The request by `this.request` didn't work.
      */
      _dataLoaderError: function(){
        //console.log("RESPONDED WITH ERROR!");
      },

      _fireEventSubmit( msg ){
        this.fire( 'user-message-info', { message: msg } );
      },

      _fireEventResponse( msg ){
        this.fire( 'user-message-success', { message: msg } );
      },

      _fireEventError( msg ){
        this.fire( 'user-message-error', { message: msg } );
      },

      // **********************************************************
      // FUNCTIONS RE: SUBMITTING FORMS AND GETTING response
      // Everything needed for form submission (preparation, etc.)
      // **********************************************************

      /**
       * Set the right URL in the form's `request` widget (which will
       * actually make the request)
      */
      _prepareToSubmit: function( e ){

        var form = this.form;
        var request = form.request;

        // If it's a PUT, then the actual URL for the request needs to include
        // the ID (if present)
        //if( form.getAttribute( 'method' ).toUpperCase() === 'PUT' ){

        //request.body = this.form.serialize();
        //request.params = {};

        // Set the correct URL for the PUT
        if( this.recordId ){
          request.url = form.getAttribute('action') + "/" + this.recordId;
          request.method = "PUT";
        } else {
          request.url = form.getAttribute('action');
        }

      },

      /**
       * Set the right error messages in the corresponding fields
      */
      _setErrorsInFields( returnObject ){
        var found;
        var form = this.form;
        if( form && returnObject && typeof returnObject === 'object' && Array.isArray( returnObject.errors ) ){

          for( var i = 0, l = returnObject.errors.length; i < l; i ++ ){
            var error = returnObject.errors[ i ];

            var domField = this.form.$$(`[name='${error.field}']`)
            if( domField ){
              domField.errorMessage = error.message;
              domField.invalid = true;
            }
          };
        }
      },

      _formSubmit( e ){

        // Make submit button busy, now that submission is actually underway
        this.submitButton.disabled = true;
        this.form.disabled = true;

        // Give a submit message
        if( this.submitMessage != '' ){
          this._fireEventSubmit( this.submitMessage );
        }
      },

      _formError( e ){
        var returnObject = e.detail.request.xhr.response;
        if( returnObject && typeof returnObject === 'object' ){
          this._fireEventError( returnObject.message );
        } else {
          this._fireEventError( this.defaultErrorMessage );
        }
        this._setErrorsInFields( returnObject );
        this.submitButton.disabled = false;
        this.form.disabled = false;
      },

      _formResponse( e ){
        if( this.successMessage != '' ){
          this._fireEventResponse( this.successMessage );
        }
        this.submitButton.disabled = false;
        this.form.disabled = false;


        if( this.recordId ){
          propToCheck = 'actionAfterPutResponse';
        } else {
          propToCheck = 'actionAfterPostResponse';
        }

        // Either
        // * reset the form (default for POST)
        // * set fields depending on what came back (default for PUT)
        if( this[ propToCheck ] === 'reset' ){
          this.form.reset();
        } else if( this[ propToCheck ] === 'set' ){
          this._setFieldsAsObject( e.detail.response );
        }
      },

      // **********************************************************
      // UTILITY FUNCTIONS
      // **********************************************************
      _setFieldsAsObject: function( r ){
        if( typeof r === 'object' && r !== null ){

          for( var k in r ){
            var domField = this.form.$$(`[name='${k}']`)

            if( domField ){

              if (this.form._usesCheckedInsteadOfValue( domField ) ){
                domField.checked  = r[ k ];
                valueProperty = 'checked';
              } else {
                domField.value = r[ k ]
              }
            }
          };
        }
      },

    });
  </script>
</dom-module>
